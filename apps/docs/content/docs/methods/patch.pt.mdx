---
title: Patch
icon: HiPlusCircle
---
import { TypeTable } from "fumadocs-ui/components/type-table";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";

<div className="w-full flex items-center justify-center"><span className="text-4xl font-bold">‚ûï M√©todo: Patch</span></div>

O m√©todo `patch` √© a **fun√ß√£o principal do Tusk**, permitindo modificar ou estender m√©todos dinamicamente em tempo de execu√ß√£o.  
Ele foi projetado para ser **seguro, limpo e f√°cil de usar**, tornando o monkey patching muito mais simples! üå¨Ô∏è

---

<Callout type="info" title="Diferen√ßas Entre 'original()' e 'original.call(this)'">
  - **Use `original.call(this)` quando:** O m√©todo depende do `this`, como ao acessar propriedades do objeto (`this.value`, `this.name`). Sem `call(this)`, o `this` pode ser `undefined`, causando erros.
  - **Use `original()` quando:** A fun√ß√£o n√£o depende do `this`, como fun√ß√µes est√°ticas (`Math.max`), fun√ß√µes independentes ou m√©todos que usam apenas argumentos passados sem referenciar o `this`.
</Callout>

## Sintaxe
```ts
patch(target: Object, methodName: string, implementation: Function): void;
``` 

## Par√¢metros
<TypeTable
  type={{
    target: {
      description:
        "O objeto ou prot√≥tipo que voc√™ deseja modificar.",
      type: "Object",
      required: true
    },
    methodName: {
      description:
        "O nome do m√©todo que ser√° sobrescrito.",
      type: "string",
      required: true
    },
    implementation: {
      description:
        "A nova implementa√ß√£o do m√©todo. Recebe o m√©todo original como primeiro par√¢metro.",
      type: "Function",
      required: true
    },
  }}
/>

## Exemplo de Uso
Extendendo o prot√≥tipo de Array com um m√©todo `flat`
```ts title="math.ts"
import { patch } from "tusk";

patch(Array.prototype, "flat", function (original, depth) {
    const flattened = original.call(this, depth); 
    return flattened.map(() => 0); 
});

const map = [1, 2, 3, 4, 5];
const flattenedArray = map.flat();
console.log(flattenedArray); // Output: [0, 0, 0, 0]
``` 

### Corrigindo uma Biblioteca de Terceiros
Patch para evitar duplicatas no m√©todo `insertMultiple`
```ts title="list.ts"
import { patch } from "tusk";

import { ListManager } from "listner";

const oldManager = new ListManager();
oldManager.insertMultiple([{ id: 1, name: "Item 1" }, { id: 2, name: "Item 2" }]);
oldManager.insertMultiple([{ id: 2, name: "Item 2" }, { id: 3, name: "Item 3" }]);

console.log(oldManager.getAll());
/*                                                                                   */

patch(ListManager.prototype, "insertMultiple", function(original, items) {
    const existingItems = this.getAll();
    const newItems = items.filter(item => 
        !existingItems.some(existing => existing.id === item.id)
    );
    if (newItems.length > 0) {
        original.call(this, newItems);
    }
});

const manager = new ListManager();
manager.insertMultiple([{ id: 1, name: "Item 1" }, { id: 2, name: "Item 2" }]);
manager.insertMultiple([{ id: 2, name: "Item 2" }, { id: 3, name: "Item 3" }]);

console.log(manager.getAll());
```
#### Sa√≠da
<Tabs items={["Antes", "Depois"]}>
    <Tab>
        O item `{ id: 2, name: "Item 2" }` foi adicionado novamente porque o m√©todo original n√£o verificava duplicatas.
        ```bash title="terminal"
        [
            { id: 1, name: "Item 1" },
            { id: 2, name: "Item 2" },
            { id: 2, name: "Item 2" },
            { id: 3, name: "Item 3" }
        ]
        ```
    </Tab>
    <Tab>
        Ap√≥s o patch, a duplicata `{ id: 2, name: "Item 2" }` n√£o foi adicionada, pois o m√©todo agora verifica se o item j√° existe antes da inser√ß√£o.
        ```bash title="terminal"
        [
            { id: 1, name: "Item 1" },
            { id: 2, name: "Item 2" },
            { id: 3, name: "Item 3" }
        ]
        ```
    </Tab>
</Tabs>

---

**üß† Dica Pro** ‚ï∫‚ï∏ Teste seus patches em um ambiente controlado antes de implement√°-los em produ√ß√£o para evitar efeitos colaterais inesperados!